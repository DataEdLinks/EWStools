################################################################################
# Model Search
################################################################################


##' @title Generate a list of \code{\linkS4class{ROCit}} objects for different datasets
##' @param fit a \code{\linkS4class{ROCit}} object generated by \code{\link{ROCtest}}
##' @param datatype a named character representing the accuracy object be built on either "train" or "test" data, 
##' user can include both
##' @param testdata a list of length two containing a named slot for the matrix of predictors 
##' (pred) and the vector of classes (class)
##' @param modelKeep a logical indicating whether the original model object should be stored
##' @return a list with the following:
##' \itemize{
##' \item{method - the \code{\link{train}} method used to fit the model}
##' \item{summaryTr - the \code{\linkS4class{ROCit}} for the training data}
##' \item{summaryTe - the \code{\linkS4class{ROCit}} for the test data}
##' \item{time - the time reported for the model to run, taken from the \code{\link{train}} object if available}
##' }
##' @note The values presented are for the optimal threshold as computed by the \code{\link{roc}} function.
##' @export
modAcc <- function(fit, datatype = c("test", "train"), testdata, modelKeep = FALSE, ...){
  if (length(datatype) > 1){
    ROCtr <- ROCtest(fit, ...)
    ROCte <-  ROCtest(fit, testdata=list(preds = testdata$preds, 
                                          class = testdata$class), ...)    
  } else if(length(datatype) < 2 & datatype=="test"){
    ROCte <- ROCtest(fit, testdata=list(preds = testdata$preds, 
                                        class = testdata$class), ...)
    ROCtr <- NULL
  } else if (length(datatype) < 2 & datatype=="train"){
    ROCtr <- ROCtest(fit, ...)
    ROCte <- NULL
  }
  if(modelKeep == TRUE){
    return(list(model=fit, summaryTr = ROCtr, summaryTe = ROCte, method=fit$method, 
                time = fit$times$everything[3]))
  } else if(modelKeep == FALSE){
    return(list(method=fit$method, summaryTr = ROCtr, summaryTe = ROCte, 
                time = fit$times$everything[3]))
  }
  
}

##' @title Generate a dataframe from \code{\link{modAcc}} lists
##' @description Used for generating the data to make good looking ROC curves of 
##' training and test data.
##' @param mod a list resulting from a call to \code{\link{modAcc}}
##' @return a \code{\link{data.frame}} with the following columns:
##' \itemize{
##' \item{sens - the sensitivities of the model at various thresholds}
##' \item{spec - the specificities of the model at various thresholds}
##' \item{grp - whether the model is using training or test data}
##' \item{method - the model method}
##' \item{auc - the area under the curve}
##' \item{elapsedTime - the time reported for the model to run}
##' }
##' @note The sensitivities and specificities come from the \code{\link{roc}} object stored in the 
##' \code{\linkS4class{ROCit}} object
##' @export 
dfExtract <- function(mod){
  if(class(mod$summaryTr) != "NULL"){
      newdatB <- data.frame(sens = smooth(mod$summaryTr@rocobj)$sensitivities, 
                            spec = smooth(mod$summaryTr@rocobj)$specificities, 
                            grp="train", 
                            auc = mod$summaryTr@auc,
                            method = mod$method, 
                            elapsedTime = ifelse(is.null(mod$time), NA, mod$time), 
                            check.rows=FALSE, 
                            row.names=NULL)
      }
    if(class(mod$summaryTe) != "NULL"){
      newdatA <- data.frame(sens = smooth(mod$summaryTe@rocobj)$sensitivities, 
                            spec = smooth(mod$summaryTe@rocobj)$specificities, 
                            grp="test",
                            auc  = mod$summaryTe@auc,
                            method = mod$method, 
                            elapsedTime =ifelse(is.null(mod$time), NA, mod$time), 
                            check.rows=FALSE, 
                            row.names=NULL)
      }    
    if(class(mod$summaryTr) != "NULL" & class(mod$summaryTe) != "NULL"){
      tmp <- rbind(newdatA, newdatB)
    } else if(class(mod$summaryTr) != "NULL"){
      tmp <- newdatB
    } else if(class(mod$summaryTe) != "NULL"){
      tmp <- newdatA
    }
    tmp$sens <- as.numeric(tmp$sens)
    tmp$spec <- as.numeric(tmp$spec)
    tmp$auc <- as.numeric(tmp$auc)
    tmp$method <- as.character(tmp$method)
    tmp$auc <- as.numeric(tmp$auc)
    tmp$grp <- as.character(tmp$grp)
    tmp$elapsedTime <- as.numeric(tmp$elapsedTime)
    return(tmp)
}

##' @title Train a model and store \code{\linkS4class{ROCit}} tests on different datasets
##' @description This function wraps the \code{train} function in the \code{caret} package with model accuracy reports. 
##' It also allows for errors in fitting models to be caught to make it easier to use in a loop. 
##' @param method a a string specifying which classification or regression model to use. Possible values are found using \code{names(getModelInfo())}. See http://caret.r-forge.r-project.org/bytag.html. A list of funciotns can also be passed for a custom model function. See http://caret.r-forge.r-project.org/custom_models.html for details
##' @param datatype a named character representing the accuracy object be built on either "train" or "test" data, 
##' user can include both
##' @param traindata a list of length two containing a named slot for the matrix of predictors 
##' (pred) and the vector of classes (class)
##' @param testdata a list of length two containing a named slot for the matrix of predictors 
##' (pred) and the vector of classes (class)
##' @param modelKeep a logical indicating whether the original model object should be stored
##' @param length an integer denoting the number of levels of each tuning parameter 
##' that should be generated to be passed to \code{tuneLength} in the \code{train} call
##' @param omit an integer or vector of integers denoting the column of numbers to 
##' exclude in the predictor matrix for a subset of \code{train} methods. See details 
##' for more information.
##' @param fitControl an object generated by \code{trainControl} to control the
##'  behavior of \code{train}. If none is given a default is selected.
##' @param metric a character string passed to \code{train}. a string that specifies what 
##' summary metric will be used to select the optimal model. By default, possible 
##' values are "RMSE" and "Rsquared" for regression and "Accuracy" and "Kappa" for 
##' classification. If custom performance metrics are used (via the \code{summaryFunction}
##' argument in trainControl, the value of metric should match one of the arguments. 
##' If it does not, a warning is issued and the first metric given by the 
##' summaryFunction is used. 
##' @return A character string with an error if unsuccessful. The result of the \code{modAcc} call if successful: 
##' \itemize{
##' \item{method - the \code{\link{train}} method used to fit the model}
##' \item{summaryTr - the \code{\linkS4class{ROCit}} for the training data}
##' \item{summaryTe - the \code{\linkS4class{ROCit}} for the test data}
##' \item{time - the time reported for the model to run, taken from the \code{\link{train}} object if available}
##' }
##' @note The values presented are for the optimal threshold as computed by the \code{\link{roc}} function.
##' @export
modSearch <- function(method, datatype=c("train", "test"), traindata, testdata, 
                      modelKeep=NULL, length,  
                      omit = NULL, fitControl = NULL, metric = "ROC"){
  # Let's dump out some defaults
  #
  #
  datD <- c("rda", "lda2", "hda", 'mlp', 'mlpWeightDecay', 'rbf', 'rpart2', 
            "treebag", 'rf', 'plr', 'lda', 'xyf')
  if(x %in% datD){
    fit <- tryCatch({
      train(traindata$preds[, -omit], traindata$class,
            method=method,
            trControl=fitControl,
            tuneLength = length, metric= metric)}, error = function(e) e, 
      finally = print(paste0("Model failed to run: ", e)))
  } else {
    fit <- tryCatch({
      train(traindata$preds, traindata$class,
            method=method,
            trControl=fitControl,
            tuneLength = length, metric= metric)}, error = function(e) e, 
      finally = print(paste0("Model failed to run: ", e)))
  }
  if(class(fit) == "character"){
    cat(fit)
    
  } else if(class(fit) == "train"){
    if (length(datatype) > 1){
      if(x %in% datD){
        fitSum <- modAcc(fit, datatype = datatype, 
                         testdata=list(preds = testdata$preds[, -omit], 
                                       class = testdata$class ), 
                         modelKeep == FALSE)
      } else {
        fitSum <- modAcc(fit, datatype = datatype, 
                         testdata=testdata, 
                         modelKeep == FALSE)
      }
      
    }
  }
  return(fitSum)
}

##' @title Generate an empty dataframe to match \code{\link{modAcc}} lists
##' @description Used for generating the data to make good looking ROC curves of 
##' training and test data.
##' @param methods a list of \code{train} method names to generate the dataframe for
##' @return a \code{\link{data.frame}} with the following columns:
##' \itemize{
##' \item{sens - the sensitivities of the model at various thresholds}
##' \item{spec - the specificities of the model at various thresholds}
##' \item{grp - whether the model is using training or test data}
##' \item{auc - the area under the curve}
##' \item{method - the model method}
##' \item{elapsedTime - the time reported for the model to run}
##' }
##' @note The sensitivities and specificities come from the \code{\link{roc}} object stored in the 
##' \code{\linkS4class{ROCit}} object
buildROCcurveFrame <- function(methods){
  ModelFits <- expand.grid(sens = NA, spec = NA, grp = NA, auc = NA, 
                           method = rep(methods, each = 1028), 
                           elapsedTime = NA)
  
  # Class variables correctly to avoid errors
  ModelFits$grp <- as.character(ModelFits$grp)
  ModelFits$method <- as.character(ModelFits$method)
  ModelFits$sens <- as.numeric(ModelFits$sens)
  ModelFits$spec <- as.numeric(ModelFits$spec)
  ModelFits$auc <- as.numeric(ModelFits$auc)
  return(ModelFits)
  
}




############################################
# Loop through candidate mods
for(i in candidatemods){
  p <- match(i, candidatemods)
  fit <- try(modSearch(i, datatype=c("test","train"), modelKeep=FALSE, 
                       length = LENGTH, timeout = TIMEOUT))
  tmp <- tryCatch(dfExtract(fit), error = function(e) "No Model Ran")
  #
  if(class(tmp) == "data.frame"){
    ModelFits[ModelFits$method == i,] <- tmp[tmp$method == i,]
  } else{
    ModelFits <- ModelFits
    print(paste(tmp, "failure for model type:", i, sep=" "))
  }
  setTxtProgressBar(pb, p)
}

