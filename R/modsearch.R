################################################################################
# Model Search
################################################################################


##' @title Generate a list of \code{\linkS4class{ROCit}} objects for different datasets
##' @param fit a \code{\linkS4class{ROCit}} object generated by \code{\link{ROCtest}}
##' @param datatype a named character representing the accuracy object be built on either "train" or "test" data, 
##' user can include both
##' @param testdata a list of length two containing a named slot for the matrix of predictors 
##' (pred) and the vector of classes (class)
##' @param modelKeep a logical indicating whether the original model object should be stored
##' @return a list with the following:
##' \itemize{
##' \item{method - the \code{\link{train}} method used to fit the model}
##' \item{summaryTr - the \code{\linkS4class{ROCit}} for the training data}
##' \item{summaryTe - the \code{\linkS4class{ROCit}} for the test data}
##' \item{time - the time reported for the model to run, taken from the \code{\link{train}} object if available}
##' }
##' @note The values presented are for the optimal threshold as computed by the \code{\link{roc}} function.
##' @export
modAcc <- function(fit, datatype = c("test", "train"), testdata, modelKeep = FALSE, ...){
  if (length(datatype) > 1){
    ROCtr <- ROCtest(fit, ...)
    ROCte <-  ROCtest(fit, testdata=list(preds = testdata$preds, 
                                          class = testdata$class), ...)    
  } else if(length(datatype) < 2 & datatype=="test"){
    ROCte <- ROCtest(fit, testdata=list(preds = testdata$preds, 
                                        class = testdata$class), ...)
    ROCtr <- NULL
  } else if (length(datatype) < 2 & datatype=="train"){
    ROCtr <- ROCtest(fit, ...)
    ROCte <- NULL
  }
  if(modelKeep == TRUE){
    return(list(model=fit, summaryTr = ROCtr, summaryTe = ROCte, method=fit$method, 
                time = fit$times$everything[3]))
  } else if(modelKeep == FALSE){
    return(list(method=fit$method, summaryTr = ROCtr, summaryTe = ROCte, 
                time = fit$times$everything[3]))
  }
  
}

##' @title Generate a dataframe from \code{\link{modAcc}} lists
##' @description Used for generating the data to make good looking ROC curves of 
##' training and test data.
##' @param mod a list resulting from a call to \code{\link{modAcc}}
##' @return a \code{\link{data.frame}} with the following columns:
##' \itemize{
##' \item{sens - the sensitivities of the model at various thresholds}
##' \item{spec - the specificities of the model at various thresholds}
##' \item{grp - whether the model is using training or test data}
##' \item{method - the model method}
##' \item{elapsedTime - the time reported for the model to run}
##' }
##' @note The sensitivities and specificities come from the \code{\link{roc}} object stored in the 
##' \code{\linkS4class{ROCit}} object
##' @export 
dfExtract <- function(mod){
  if(class(mod$summaryTr) != "NULL"){
      newdatB <- data.frame(sens = smooth(mod$summaryTr@rocobj)$sensitivities, 
                            spec = smooth(mod$summaryTr@rocobj)$specificities, 
                            grp="train", 
                            auc = mod$summaryTr@auc,
                            method = mod$method, 
                            elapsedTime = ifelse(is.null(mod$time), NA, mod$time), 
                            check.rows=FALSE, 
                            row.names=NULL)
      }
    if(class(mod$summaryTe) != "NULL"){
      newdatA <- data.frame(sens = smooth(mod$summaryTe@rocobj)$sensitivities, 
                            spec = smooth(mod$summaryTe@rocobj)$specificities, 
                            grp="test",
                            auc  = mod$summaryTe@auc,
                            method = mod$method, 
                            elapsedTime =ifelse(is.null(mod$time), NA, mod$time), 
                            check.rows=FALSE, 
                            row.names=NULL)
      }    
    if(class(mod$summaryTr) != "NULL" & class(mod$summaryTe) != "NULL"){
      tmp <- rbind(newdatA, newdatB)
    } else if(class(mod$summaryTr) != "NULL"){
      tmp <- newdatB
    } else if(class(mod$summaryTe) != "NULL"){
      tmp <- newdatA
    }
    tmp$sens <- as.numeric(tmp$sens)
    tmp$spec <- as.numeric(tmp$spec)
    tmp$auc <- as.numeric(tmp$auc)
    tmp$method <- as.character(tmp$method)
    tmp$auc <- as.numeric(tmp$auc)
    tmp$grp <- as.character(tmp$grp)
    tmp$elapsedTime <- as.numeric(tmp$elapsedTime)
    return(tmp)
}

##' @title Generate a list of \code{\linkS4class{ROCit}} objects for different datasets
##' @param fit a \code{\linkS4class{ROCit}} object generated by \code{\link{ROCtest}}
##' @param datatype a named character representing the accuracy object be built on either "train" or "test" data, 
##' user can include both
##' @param testdata a list of length two containing a named slot for the matrix of predictors 
##' (pred) and the vector of classes (class)
##' @param modelKeep a logical indicating whether the original model object should be stored
##' @return a list with the following:
##' \itemize{
##' \item{method - the \code{\link{train}} method used to fit the model}
##' \item{summaryTr - the \code{\linkS4class{ROCit}} for the training data}
##' \item{summaryTe - the \code{\linkS4class{ROCit}} for the test data}
##' \item{time - the time reported for the model to run, taken from the \code{\link{train}} object if available}
##' }
##' @note The values presented are for the optimal threshold as computed by the \code{\link{roc}} function.
##' @export
modSearch <- function(x, datatype=c("train", "test"), modelKeep=NULL, 
                      length = LENGTH, timeout = NULL){
  datD <- c("rda", "lda2", "hda", 'mlp', 'mlpWeightDecay', 'rbf', 'rpart2', 
            "treebag", 'rf', 'plr', 'lda', 'xyf')
  if(x %in% datD){
    fit <- tryCatch({
      train(trainData[, -9], trainCLASS,
            method=x,
            trControl=fitControl,
            tuneLength = length, metric="ROC")})
  } else {
    fit <- tryCatch({
      train(trainData, trainCLASS,
            method=x,
            trControl=fitControl,
            tuneLength = length, metric="ROC")})
  }
  if(class(fit) == "character"){
    cat(fit)
    
  } else if(class(fit) == "train"){
    if (length(datatype) > 1){
      if(x %in% datD){
        fitSum <- modAcc(fit, datatype = datatype, 
                         testdata=list(preds = testData[, -9], class = testCLASS), 
                         modelKeep == FALSE)
      } else {
        fitSum <- modAcc(fit, datatype = datatype, 
                         testdata=list(preds = testData, class = testCLASS), 
                         modelKeep == FALSE)
      }
      
    }
  }
  return(fitSum)
}

######### Build modelfits frame
# Set up a dataframe to capture model fit

ModelFits <- expand.grid(sens = NA, spec = NA, grp = NA, auc = NA, 
                         method = rep(candidatemods, each = 1028), 
                         elapsedTime = NA)

# Class variables correctly to avoid errors
ModelFits$grp <- as.character(ModelFits$grp)
ModelFits$method <- as.character(ModelFits$method)
ModelFits$sens <- as.numeric(ModelFits$sens)
ModelFits$spec <- as.numeric(ModelFits$spec)
ModelFits$auc <- as.numeric(ModelFits$auc)


############################################
# Loop through candidate mods
for(i in candidatemods){
  p <- match(i, candidatemods)
  fit <- try(modSearch(i, datatype=c("test","train"), modelKeep=FALSE, 
                       length = LENGTH, timeout = TIMEOUT))
  tmp <- tryCatch(dfExtract(fit), error = function(e) "No Model Ran")
  #
  if(class(tmp) == "data.frame"){
    ModelFits[ModelFits$method == i,] <- tmp[tmp$method == i,]
  } else{
    ModelFits <- ModelFits
    print(paste(tmp, "failure for model type:", i, sep=" "))
  }
  setTxtProgressBar(pb, p)
}

